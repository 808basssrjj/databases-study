# 一. 过期数据

**Redis中的数据特征**

Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态

-  XX ：具有时效性的数据

-  -1 ：永久有效的数据

- -2  ：已经过期的数据 或 被删除的数据 或 未定义的数据



当redis发出一系列的指令给CPU去处理，指令少的时候CPU表示毫无压力，但是针对大批量的指令过来的时候，虽然在排着队执行，CPU的性能就会下来。对redis来说，一旦数据过期的时候，并不会立即删除，还是在内存中，等要删除的时候再去删除，怎么删除，就是redis的删除策略？

因此，过期数据是指那些设置过有效期又达到有效期之后的数据。有的数据可能很久才会被删除。





# 二. 删除策略

**数据删除策略的目标**

​	在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄露





## 1. 定时删除

- 创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作

- 优点：节约内存，到时就删除，快速释放掉不必要的内存占用

- 缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量

- 总结：用处理器性能换取存储空间（拿时间换空间）



## **2. 惰性删除**

- 数据到达过期时间，不做处理。等下次访问该数据时

- 如果未过期，返回数据

- 发现已过期，删除，返回不存在

- 优点：节约CPU性能，发现必须删除的时候才删除

- 缺点：内存压力很大，出现长期占用内存的数据

- 总结：用存储空间换取处理器性能 （拿空间换时间）



在redis获取数据时都会执行**expireIfNeeded()**方法



## 3. **定期删除**

**两种方案都走极端，有没有折中方案？**

- 周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度

-  特点1：CPU性能占用设置有峰值，检测频度可自定义设置

- 特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理

- 总结：周期性抽查存储空间（随机抽查，重点抽查）



**具体过程**

- Redis启动服务器初始化时，读取配置server.hz的值，默认为10

- 每秒钟执行server.hz次**serverCron()** -> databaseCron() -> activeExpireCydle()

- **activeExpireCycle()**对每个expires[*]逐一进行检测，每次执行250ms/server.hz

- 对某个expires[*]检测时，随机挑选W个key检测
  - 如果key超时，删除key
  - 如果一轮中删除的key的数量>W*25%，循环该过程
  - 如果一轮中删除的key的数量≤W*25%，检查下一个expires[*]，0-15循环
  - W取值=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP属性值

- 参数current_db用于记录**activeExpireCycle()** 进入哪个expires[*] 执行

- 如果**activeExpireCycle()**执行时间到期，下次从current_db继续向下执行





## 4. 策略比对

| 定时删除 | 节约内存, 无占用 | 部分时段占用cpu资源, 频度高   | 拿时间换空间       |
| :------: | ---------------- | ----------------------------- | ------------------ |
| 惰性删除 | 内存占用严重     | 延时执行，CPU利用率高         | 拿空间换时间       |
| 定期删除 | 内存定期随机清理 | 每秒花费固定的CPU资源维护内存 | 随机抽查, 重点抽查 |



**redis用的是 惰性删除和定期删除**





# 三. 逐出算法

**上面我们说的删除策略操作的都是expire，都是有时效性的数据，失效了但是还在内存，要是所有数据都没过期，甚至都是永久有效的，内存不够了，这个添加数据会怎么样？**



- Redis使用内存存储数据，在执行每一个命令前，会调用**freeMemoryIfNeeded()**检测内存是否充足。如

  果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据

  的策略称为逐出算法。

- 注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所

  有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。



**1. 影响数据逐出的相关配置**

- 最大可使用内存

  **maxmemory**

   占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。

- 每次选取待删除数据的个数

  **maxmemory-samples**

   选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据

- 删除策略

  **maxmemory-policy**

   达到最大内存后的，对被挑选出来的数据进行删除的策略



**2. 逐出策略有哪几种呢？**

检测易失数据（可能会过期的数据集server.db[i].expires ） ：

- volatile-lru：挑选最近最少使用的数据进行淘汰          (算时间 least recently used)
- volatile-lfu：挑选最近使用次数最少的数据进行淘汰  (算次数 least frequently used)
- volatile-ttl：挑选将要过期的数据淘汰
- volatile-random：任意选择数据淘汰

检测全库数据（所有数据集server.db[i].dict ） ：

- allkeys-lru：挑选最近使用的数据进行淘汰
- allkeys-lfu：挑选最近使用次数最少的数据进行淘汰
- allkeys-random：任意选择数据淘汰

放弃驱逐策略：

- no-eviction：禁止驱逐数据，会引发错误OOM（Out Of Memory）





**3. 数据逐出策略配置依据**

- 使用INFO命令输出监控信息，查询缓存 hit 和 miss 的次数，根据业务需求调优Redis配置





# 四. redis核心配置

**1. 服务器端设定**

- 设置服务器以守护进程的方式运行

  **daemonize** yes**|**no

- 绑定主机地址

  **bind** 127.0.0.1

- 设置服务器端口号

  **port** 6379

- 设置数据库数量

  **databases** 16

  

**2. 日志配置**

- 设置服务器以指定日志记录级别

  **loglevel** debug**|verbose|**notice**|**warning

- 日志记录文件名

- **logfile** 端口号.log



**3. 客户端配置**

- 设置同一时间最大客户端连接数，默认无限制。当客户端连接到达上限，Redis会关闭新的连接

  **maxclients** 0 

- 客户端闲置等待最大时长，达到最大值后关闭连接。如需关闭该功能，设置为 0

  **timeout** 300



**4. 多服务器快捷配置**

- 导入并加载指定配置文件信息，用于快速创建redis公共配置较多的redis实例配置文件，便于维护

  **include** /path/server-端口号.conf























